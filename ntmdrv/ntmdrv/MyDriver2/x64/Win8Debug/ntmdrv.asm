; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	GUID_HWPROFILE_QUERY_CHANGE
PUBLIC	GUID_HWPROFILE_CHANGE_CANCELLED
PUBLIC	GUID_HWPROFILE_CHANGE_COMPLETE
PUBLIC	GUID_DEVICE_INTERFACE_ARRIVAL
PUBLIC	GUID_DEVICE_INTERFACE_REMOVAL
PUBLIC	GUID_TARGET_DEVICE_QUERY_REMOVE
PUBLIC	GUID_TARGET_DEVICE_REMOVE_CANCELLED
PUBLIC	GUID_TARGET_DEVICE_REMOVE_COMPLETE
PUBLIC	GUID_PNP_CUSTOM_NOTIFICATION
PUBLIC	GUID_PNP_POWER_NOTIFICATION
PUBLIC	GUID_PNP_POWER_SETTING_CHANGE
PUBLIC	GUID_TARGET_DEVICE_TRANSPORT_RELATIONS_CHANGED
PUBLIC	GUID_BUS_INTERFACE_STANDARD
PUBLIC	GUID_PCI_BUS_INTERFACE_STANDARD
PUBLIC	GUID_PCI_BUS_INTERFACE_STANDARD2
PUBLIC	GUID_ARBITER_INTERFACE_STANDARD
PUBLIC	GUID_TRANSLATOR_INTERFACE_STANDARD
PUBLIC	GUID_ACPI_INTERFACE_STANDARD
PUBLIC	GUID_INT_ROUTE_INTERFACE_STANDARD
PUBLIC	GUID_PCMCIA_BUS_INTERFACE_STANDARD
PUBLIC	GUID_ACPI_REGS_INTERFACE_STANDARD
PUBLIC	GUID_LEGACY_DEVICE_DETECTION_STANDARD
PUBLIC	GUID_PCI_DEVICE_PRESENT_INTERFACE
PUBLIC	GUID_MF_ENUMERATION_INTERFACE
PUBLIC	GUID_REENUMERATE_SELF_INTERFACE_STANDARD
PUBLIC	GUID_AGP_TARGET_BUS_INTERFACE_STANDARD
PUBLIC	GUID_ACPI_CMOS_INTERFACE_STANDARD
PUBLIC	GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD
PUBLIC	GUID_ACPI_INTERFACE_STANDARD2
PUBLIC	GUID_PNP_LOCATION_INTERFACE
PUBLIC	GUID_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE
PUBLIC	GUID_PCI_EXPRESS_ROOT_PORT_INTERFACE
PUBLIC	GUID_MSIX_TABLE_CONFIG_INTERFACE
PUBLIC	GUID_D3COLD_SUPPORT_INTERFACE
PUBLIC	GUID_PROCESSOR_PCC_INTERFACE_STANDARD
PUBLIC	GUID_PCI_VIRTUALIZATION_INTERFACE
PUBLIC	GUID_PCC_INTERFACE_STANDARD
PUBLIC	GUID_PCC_INTERFACE_INTERNAL
PUBLIC	GUID_THERMAL_COOLING_INTERFACE
PUBLIC	GUID_BUS_TYPE_INTERNAL
PUBLIC	GUID_BUS_TYPE_PCMCIA
PUBLIC	GUID_BUS_TYPE_PCI
PUBLIC	GUID_BUS_TYPE_ISAPNP
PUBLIC	GUID_BUS_TYPE_EISA
PUBLIC	GUID_BUS_TYPE_MCA
PUBLIC	GUID_BUS_TYPE_SERENUM
PUBLIC	GUID_BUS_TYPE_USB
PUBLIC	GUID_BUS_TYPE_LPTENUM
PUBLIC	GUID_BUS_TYPE_USBPRINT
PUBLIC	GUID_BUS_TYPE_DOT4PRT
PUBLIC	GUID_BUS_TYPE_1394
PUBLIC	GUID_BUS_TYPE_HID
PUBLIC	GUID_BUS_TYPE_AVC
PUBLIC	GUID_BUS_TYPE_IRDA
PUBLIC	GUID_BUS_TYPE_SD
PUBLIC	GUID_BUS_TYPE_ACPI
PUBLIC	GUID_BUS_TYPE_SW_DEVICE
PUBLIC	GUID_POWER_DEVICE_ENABLE
PUBLIC	GUID_POWER_DEVICE_TIMEOUTS
PUBLIC	GUID_POWER_DEVICE_WAKE_ENABLE
PUBLIC	GUID_WUDF_DEVICE_HOST_PROBLEM
PUBLIC	GUID_PARTITION_UNIT_INTERFACE_STANDARD
PUBLIC	?oldFunction@@3_KA				; oldFunction
PUBLIC	?OriginalFunction@@3PA_KA			; OriginalFunction
PUBLIC	?g_ExitEvent@@3U_KEVENT@@A			; g_ExitEvent
PUBLIC	?g_MtEvent@@3U_KEVENT@@A			; g_MtEvent
PUBLIC	?NotifyLock@@3_KA				; NotifyLock
PUBLIC	?gExit@@3HA					; gExit
_BSS	SEGMENT
?oldFunction@@3_KA DQ 01H DUP (?)			; oldFunction
?OriginalFunction@@3PA_KA DQ 08H DUP (?)		; OriginalFunction
?g_ExitEvent@@3U_KEVENT@@A DB 018H DUP (?)		; g_ExitEvent
?g_MtEvent@@3U_KEVENT@@A DB 018H DUP (?)		; g_MtEvent
?NotifyLock@@3_KA DQ 01H DUP (?)			; NotifyLock
?gExit@@3HA DD	01H DUP (?)				; gExit
_BSS	ENDS
;	COMDAT GUID_PARTITION_UNIT_INTERFACE_STANDARD
CONST	SEGMENT
GUID_PARTITION_UNIT_INTERFACE_STANDARD DD 052363f5bH
	DW	0d891H
	DW	0429bH
	DB	081H
	DB	095H
	DB	0aeH
	DB	0c5H
	DB	0feH
	DB	0f6H
	DB	085H
	DB	03cH
CONST	ENDS
;	COMDAT GUID_WUDF_DEVICE_HOST_PROBLEM
CONST	SEGMENT
GUID_WUDF_DEVICE_HOST_PROBLEM DD 0c43d25bdH
	DW	09346H
	DW	040eeH
	DB	0a2H
	DB	0d2H
	DB	0d7H
	DB	0cH
	DB	015H
	DB	0f8H
	DB	0b7H
	DB	05bH
CONST	ENDS
;	COMDAT GUID_POWER_DEVICE_WAKE_ENABLE
CONST	SEGMENT
GUID_POWER_DEVICE_WAKE_ENABLE DD 0a9546a82H
	DW	0feb0H
	DW	011d0H
	DB	0bdH
	DB	026H
	DB	00H
	DB	0aaH
	DB	00H
	DB	0b7H
	DB	0b3H
	DB	02aH
CONST	ENDS
;	COMDAT GUID_POWER_DEVICE_TIMEOUTS
CONST	SEGMENT
GUID_POWER_DEVICE_TIMEOUTS DD 0a45da735H
	DW	0feb0H
	DW	011d0H
	DB	0bdH
	DB	026H
	DB	00H
	DB	0aaH
	DB	00H
	DB	0b7H
	DB	0b3H
	DB	02aH
CONST	ENDS
;	COMDAT GUID_POWER_DEVICE_ENABLE
CONST	SEGMENT
GUID_POWER_DEVICE_ENABLE DD 0827c0a6fH
	DW	0feb0H
	DW	011d0H
	DB	0bdH
	DB	026H
	DB	00H
	DB	0aaH
	DB	00H
	DB	0b7H
	DB	0b3H
	DB	02aH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_SW_DEVICE
CONST	SEGMENT
GUID_BUS_TYPE_SW_DEVICE DD 06d10322H
	DW	07de0H
	DW	04cefH
	DB	08eH
	DB	025H
	DB	019H
	DB	07dH
	DB	0eH
	DB	074H
	DB	042H
	DB	0e2H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_ACPI
CONST	SEGMENT
GUID_BUS_TYPE_ACPI DD 0d7b46895H
	DW	01aH
	DW	04942H
	DB	089H
	DB	01fH
	DB	0a7H
	DB	0d4H
	DB	066H
	DB	010H
	DB	0a8H
	DB	043H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_SD
CONST	SEGMENT
GUID_BUS_TYPE_SD DD 0e700cc04H
	DW	04036H
	DW	04e89H
	DB	095H
	DB	079H
	DB	089H
	DB	0ebH
	DB	0f4H
	DB	05fH
	DB	00H
	DB	0cdH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_IRDA
CONST	SEGMENT
GUID_BUS_TYPE_IRDA DD 07ae17dc1H
	DW	0c944H
	DW	044d6H
	DB	088H
	DB	01fH
	DB	04cH
	DB	02eH
	DB	061H
	DB	05H
	DB	03bH
	DB	0c1H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_AVC
CONST	SEGMENT
GUID_BUS_TYPE_AVC DD 0c06ff265H
	DW	0ae09H
	DW	048f0H
	DB	081H
	DB	02cH
	DB	016H
	DB	075H
	DB	03dH
	DB	07cH
	DB	0baH
	DB	083H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_HID
CONST	SEGMENT
GUID_BUS_TYPE_HID DD 0eeaf37d0H
	DW	01963H
	DW	047c4H
	DB	0aaH
	DB	048H
	DB	072H
	DB	047H
	DB	06dH
	DB	0b7H
	DB	0cfH
	DB	049H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_1394
CONST	SEGMENT
GUID_BUS_TYPE_1394 DD 0f74e73ebH
	DW	09ac5H
	DW	045ebH
	DB	0beH
	DB	04dH
	DB	077H
	DB	02cH
	DB	0c7H
	DB	01dH
	DB	0dfH
	DB	0b3H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_DOT4PRT
CONST	SEGMENT
GUID_BUS_TYPE_DOT4PRT DD 0441ee001H
	DW	04342H
	DW	011d5H
	DB	0a1H
	DB	084H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	060H
	DB	052H
	DB	04dH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_USBPRINT
CONST	SEGMENT
GUID_BUS_TYPE_USBPRINT DD 0441ee000H
	DW	04342H
	DW	011d5H
	DB	0a1H
	DB	084H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	060H
	DB	052H
	DB	04dH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_LPTENUM
CONST	SEGMENT
GUID_BUS_TYPE_LPTENUM DD 0c4ca1000H
	DW	02ddcH
	DW	011d5H
	DB	0a1H
	DB	07aH
	DB	00H
	DB	0c0H
	DB	04fH
	DB	060H
	DB	052H
	DB	04dH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_USB
CONST	SEGMENT
GUID_BUS_TYPE_USB DD 09d7debbcH
	DW	0c85dH
	DW	011d1H
	DB	09eH
	DB	0b4H
	DB	00H
	DB	060H
	DB	08H
	DB	0c3H
	DB	0a1H
	DB	09aH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_SERENUM
CONST	SEGMENT
GUID_BUS_TYPE_SERENUM DD 077114a87H
	DW	08944H
	DW	011d1H
	DB	0bdH
	DB	090H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	06H
	DB	0beH
	DB	02dH
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_MCA
CONST	SEGMENT
GUID_BUS_TYPE_MCA DD 01c75997aH
	DW	0dc33H
	DW	011d0H
	DB	092H
	DB	0b2H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	05H
	DB	05fH
	DB	0c5H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_EISA
CONST	SEGMENT
GUID_BUS_TYPE_EISA DD 0ddc35509H
	DW	0f3fcH
	DW	011d0H
	DB	0a5H
	DB	037H
	DB	00H
	DB	00H
	DB	0f8H
	DB	075H
	DB	03eH
	DB	0d1H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_ISAPNP
CONST	SEGMENT
GUID_BUS_TYPE_ISAPNP DD 0e676f854H
	DW	0d87dH
	DW	011d0H
	DB	092H
	DB	0b2H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	05H
	DB	05fH
	DB	0c5H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_PCI
CONST	SEGMENT
GUID_BUS_TYPE_PCI DD 0c8ebdfb0H
	DW	0b510H
	DW	011d0H
	DB	080H
	DB	0e5H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	025H
	DB	042H
	DB	0e3H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_PCMCIA
CONST	SEGMENT
GUID_BUS_TYPE_PCMCIA DD 09343630H
	DW	0af9fH
	DW	011d0H
	DB	092H
	DB	0e9H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	01bH
	DB	030H
CONST	ENDS
;	COMDAT GUID_BUS_TYPE_INTERNAL
CONST	SEGMENT
GUID_BUS_TYPE_INTERNAL DD 01530ea73H
	DW	086bH
	DW	011d1H
	DB	0a0H
	DB	09fH
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0c3H
	DB	040H
	DB	0b1H
CONST	ENDS
;	COMDAT GUID_THERMAL_COOLING_INTERFACE
CONST	SEGMENT
GUID_THERMAL_COOLING_INTERFACE DD 0ecbe47a8H
	DW	0c498H
	DW	04bb9H
	DB	0bdH
	DB	070H
	DB	0e8H
	DB	067H
	DB	0e0H
	DB	094H
	DB	0dH
	DB	022H
CONST	ENDS
;	COMDAT GUID_PCC_INTERFACE_INTERNAL
CONST	SEGMENT
GUID_PCC_INTERFACE_INTERNAL DD 07cce62ceH
	DW	0c189H
	DW	04814H
	DB	0a6H
	DB	0a7H
	DB	012H
	DB	011H
	DB	020H
	DB	089H
	DB	0e9H
	DB	038H
CONST	ENDS
;	COMDAT GUID_PCC_INTERFACE_STANDARD
CONST	SEGMENT
GUID_PCC_INTERFACE_STANDARD DD 03ee8ba63H
	DW	0f59H
	DW	04a24H
	DB	08aH
	DB	045H
	DB	035H
	DB	080H
	DB	08bH
	DB	0ddH
	DB	012H
	DB	049H
CONST	ENDS
;	COMDAT GUID_PCI_VIRTUALIZATION_INTERFACE
CONST	SEGMENT
GUID_PCI_VIRTUALIZATION_INTERFACE DD 064897b47H
	DW	03a4aH
	DW	04d75H
	DB	0bcH
	DB	074H
	DB	089H
	DB	0ddH
	DB	06cH
	DB	07H
	DB	082H
	DB	093H
CONST	ENDS
;	COMDAT GUID_PROCESSOR_PCC_INTERFACE_STANDARD
CONST	SEGMENT
GUID_PROCESSOR_PCC_INTERFACE_STANDARD DD 037b17e9aH
	DW	0c21cH
	DW	04296H
	DB	097H
	DB	02dH
	DB	011H
	DB	0c4H
	DB	0b3H
	DB	02bH
	DB	028H
	DB	0f0H
CONST	ENDS
;	COMDAT GUID_D3COLD_SUPPORT_INTERFACE
CONST	SEGMENT
GUID_D3COLD_SUPPORT_INTERFACE DD 0b38290e5H
	DW	03cd0H
	DW	04f9dH
	DB	099H
	DB	037H
	DB	0f5H
	DB	0feH
	DB	02bH
	DB	044H
	DB	0d4H
	DB	07aH
CONST	ENDS
;	COMDAT GUID_MSIX_TABLE_CONFIG_INTERFACE
CONST	SEGMENT
GUID_MSIX_TABLE_CONFIG_INTERFACE DD 01a6a460bH
	DW	0194fH
	DW	0455dH
	DB	0b3H
	DB	04bH
	DB	0b8H
	DB	04cH
	DB	05bH
	DB	05H
	DB	071H
	DB	02bH
CONST	ENDS
;	COMDAT GUID_PCI_EXPRESS_ROOT_PORT_INTERFACE
CONST	SEGMENT
GUID_PCI_EXPRESS_ROOT_PORT_INTERFACE DD 083a7734aH
	DW	084c7H
	DW	04161H
	DB	09aH
	DB	098H
	DB	060H
	DB	00H
	DB	0edH
	DB	0cH
	DB	04aH
	DB	033H
CONST	ENDS
;	COMDAT GUID_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE
CONST	SEGMENT
GUID_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE DD 0146cd41cH
	DW	0dae3H
	DW	04437H
	DB	08aH
	DB	0ffH
	DB	02aH
	DB	0f3H
	DB	0f0H
	DB	038H
	DB	09H
	DB	09bH
CONST	ENDS
;	COMDAT GUID_PNP_LOCATION_INTERFACE
CONST	SEGMENT
GUID_PNP_LOCATION_INTERFACE DD 070211b0eH
	DW	0afbH
	DW	047dbH
	DB	0afH
	DB	0c1H
	DB	041H
	DB	0bH
	DB	0f8H
	DB	042H
	DB	049H
	DB	07aH
CONST	ENDS
;	COMDAT GUID_ACPI_INTERFACE_STANDARD2
CONST	SEGMENT
GUID_ACPI_INTERFACE_STANDARD2 DD 0e8695f63H
	DW	01831H
	DW	04870H
	DB	0a8H
	DB	0cfH
	DB	09cH
	DB	02fH
	DB	03H
	DB	0f9H
	DB	0dcH
	DB	0b5H
CONST	ENDS
;	COMDAT GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD
CONST	SEGMENT
GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD DD 0f14f609bH
	DW	0cbbdH
	DW	04957H
	DB	0a6H
	DB	074H
	DB	0bcH
	DB	00H
	DB	021H
	DB	03fH
	DB	01cH
	DB	097H
CONST	ENDS
;	COMDAT GUID_ACPI_CMOS_INTERFACE_STANDARD
CONST	SEGMENT
GUID_ACPI_CMOS_INTERFACE_STANDARD DD 03a8d0384H
	DW	06505H
	DW	040caH
	DB	0bcH
	DB	039H
	DB	056H
	DB	0c1H
	DB	05fH
	DB	08cH
	DB	05fH
	DB	0edH
CONST	ENDS
;	COMDAT GUID_AGP_TARGET_BUS_INTERFACE_STANDARD
CONST	SEGMENT
GUID_AGP_TARGET_BUS_INTERFACE_STANDARD DD 0b15cfce8H
	DW	06d1H
	DW	04d37H
	DB	09dH
	DB	04cH
	DB	0beH
	DB	0ddH
	DB	0e0H
	DB	0c2H
	DB	0a6H
	DB	0ffH
CONST	ENDS
;	COMDAT GUID_REENUMERATE_SELF_INTERFACE_STANDARD
CONST	SEGMENT
GUID_REENUMERATE_SELF_INTERFACE_STANDARD DD 02aeb0243H
	DW	06a6eH
	DW	0486bH
	DB	082H
	DB	0fcH
	DB	0d8H
	DB	015H
	DB	0f6H
	DB	0b9H
	DB	070H
	DB	06H
CONST	ENDS
;	COMDAT GUID_MF_ENUMERATION_INTERFACE
CONST	SEGMENT
GUID_MF_ENUMERATION_INTERFACE DD 0aeb895f0H
	DW	05586H
	DW	011d1H
	DB	08dH
	DB	084H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	06H
	DB	0b2H
	DB	044H
CONST	ENDS
;	COMDAT GUID_PCI_DEVICE_PRESENT_INTERFACE
CONST	SEGMENT
GUID_PCI_DEVICE_PRESENT_INTERFACE DD 0d1b82c26H
	DW	0bf49H
	DW	045efH
	DB	0b2H
	DB	016H
	DB	071H
	DB	0cbH
	DB	0d7H
	DB	088H
	DB	09bH
	DB	057H
CONST	ENDS
;	COMDAT GUID_LEGACY_DEVICE_DETECTION_STANDARD
CONST	SEGMENT
GUID_LEGACY_DEVICE_DETECTION_STANDARD DD 050feb0deH
	DW	0596aH
	DW	011d2H
	DB	0a5H
	DB	0b8H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01aH
	DB	046H
	DB	019H
CONST	ENDS
;	COMDAT GUID_ACPI_REGS_INTERFACE_STANDARD
CONST	SEGMENT
GUID_ACPI_REGS_INTERFACE_STANDARD DD 06141966H
	DW	07245H
	DW	06369H
	DB	046H
	DB	02eH
	DB	04eH
	DB	065H
	DB	06cH
	DB	073H
	DB	06fH
	DB	06eH
CONST	ENDS
;	COMDAT GUID_PCMCIA_BUS_INTERFACE_STANDARD
CONST	SEGMENT
GUID_PCMCIA_BUS_INTERFACE_STANDARD DD 076173af0H
	DW	0c504H
	DW	011d1H
	DB	094H
	DB	07fH
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	060H
	DB	0eeH
CONST	ENDS
;	COMDAT GUID_INT_ROUTE_INTERFACE_STANDARD
CONST	SEGMENT
GUID_INT_ROUTE_INTERFACE_STANDARD DD 070941bf4H
	DW	073H
	DW	011d1H
	DB	0a0H
	DB	09eH
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0c3H
	DB	040H
	DB	0b1H
CONST	ENDS
;	COMDAT GUID_ACPI_INTERFACE_STANDARD
CONST	SEGMENT
GUID_ACPI_INTERFACE_STANDARD DD 0b091a08aH
	DW	0ba97H
	DW	011d0H
	DB	0bdH
	DB	014H
	DB	00H
	DB	0aaH
	DB	00H
	DB	0b7H
	DB	0b3H
	DB	02aH
CONST	ENDS
;	COMDAT GUID_TRANSLATOR_INTERFACE_STANDARD
CONST	SEGMENT
GUID_TRANSLATOR_INTERFACE_STANDARD DD 06c154a92H
	DW	0aacfH
	DW	011d0H
	DB	08dH
	DB	02aH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	06H
	DB	0b2H
	DB	044H
CONST	ENDS
;	COMDAT GUID_ARBITER_INTERFACE_STANDARD
CONST	SEGMENT
GUID_ARBITER_INTERFACE_STANDARD DD 0e644f185H
	DW	08c0eH
	DW	011d0H
	DB	0beH
	DB	0cfH
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT GUID_PCI_BUS_INTERFACE_STANDARD2
CONST	SEGMENT
GUID_PCI_BUS_INTERFACE_STANDARD2 DD 0de94e966H
	DW	0fdffH
	DW	04c9cH
	DB	099H
	DB	098H
	DB	067H
	DB	047H
	DB	0b1H
	DB	050H
	DB	0e7H
	DB	04cH
CONST	ENDS
;	COMDAT GUID_PCI_BUS_INTERFACE_STANDARD
CONST	SEGMENT
GUID_PCI_BUS_INTERFACE_STANDARD DD 0496b8281H
	DW	06f25H
	DW	011d0H
	DB	0beH
	DB	0afH
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT GUID_BUS_INTERFACE_STANDARD
CONST	SEGMENT
GUID_BUS_INTERFACE_STANDARD DD 0496b8280H
	DW	06f25H
	DW	011d0H
	DB	0beH
	DB	0afH
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT GUID_TARGET_DEVICE_TRANSPORT_RELATIONS_CHANGED
CONST	SEGMENT
GUID_TARGET_DEVICE_TRANSPORT_RELATIONS_CHANGED DD 0fcf528f6H
	DW	0a82fH
	DW	047b1H
	DB	0adH
	DB	03aH
	DB	080H
	DB	050H
	DB	059H
	DB	04cH
	DB	0adH
	DB	028H
CONST	ENDS
;	COMDAT GUID_PNP_POWER_SETTING_CHANGE
CONST	SEGMENT
GUID_PNP_POWER_SETTING_CHANGE DD 029c69b3eH
	DW	0c79aH
	DW	043bfH
	DB	0bbH
	DB	0deH
	DB	0a9H
	DB	032H
	DB	0faH
	DB	01bH
	DB	0eaH
	DB	07eH
CONST	ENDS
;	COMDAT GUID_PNP_POWER_NOTIFICATION
CONST	SEGMENT
GUID_PNP_POWER_NOTIFICATION DD 0c2cf0660H
	DW	0eb7aH
	DW	011d1H
	DB	0bdH
	DB	07fH
	DB	00H
	DB	00H
	DB	0f8H
	DB	075H
	DB	071H
	DB	0d0H
CONST	ENDS
;	COMDAT GUID_PNP_CUSTOM_NOTIFICATION
CONST	SEGMENT
GUID_PNP_CUSTOM_NOTIFICATION DD 0aca73f8eH
	DW	08d23H
	DW	011d1H
	DB	0acH
	DB	07dH
	DB	00H
	DB	00H
	DB	0f8H
	DB	075H
	DB	071H
	DB	0d0H
CONST	ENDS
;	COMDAT GUID_TARGET_DEVICE_REMOVE_COMPLETE
CONST	SEGMENT
GUID_TARGET_DEVICE_REMOVE_COMPLETE DD 0cb3a4008H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_TARGET_DEVICE_REMOVE_CANCELLED
CONST	SEGMENT
GUID_TARGET_DEVICE_REMOVE_CANCELLED DD 0cb3a4007H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_TARGET_DEVICE_QUERY_REMOVE
CONST	SEGMENT
GUID_TARGET_DEVICE_QUERY_REMOVE DD 0cb3a4006H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_DEVICE_INTERFACE_REMOVAL
CONST	SEGMENT
GUID_DEVICE_INTERFACE_REMOVAL DD 0cb3a4005H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_DEVICE_INTERFACE_ARRIVAL
CONST	SEGMENT
GUID_DEVICE_INTERFACE_ARRIVAL DD 0cb3a4004H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_HWPROFILE_CHANGE_COMPLETE
CONST	SEGMENT
GUID_HWPROFILE_CHANGE_COMPLETE DD 0cb3a4003H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_HWPROFILE_CHANGE_CANCELLED
CONST	SEGMENT
GUID_HWPROFILE_CHANGE_CANCELLED DD 0cb3a4002H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
;	COMDAT GUID_HWPROFILE_QUERY_CHANGE
CONST	SEGMENT
GUID_HWPROFILE_QUERY_CHANGE DD 0cb3a4001H
	DW	046f0H
	DW	011d0H
	DB	0b0H
	DB	08fH
	DB	00H
	DB	060H
	DB	097H
	DB	013H
	DB	05H
	DB	03fH
CONST	ENDS
PUBLIC	KeGetCurrentIrql
PUBLIC	KeGetCurrentProcessorNumber
PUBLIC	?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z	; GetIdtrAddress
PUBLIC	?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z	; GetTargetEntry
PUBLIC	?HookISR@@YAXGPEA_KH@Z				; HookISR
PUBLIC	?log2@@YAEI@Z					; log2
PUBLIC	display
PUBLIC	DriverUnload
PUBLIC	DriverEntry
PUBLIC	MyDriver_UnSupportedFunction
PUBLIC	?SystemMtThread@@YAXPEAX@Z			; SystemMtThread
PUBLIC	??_C@_0BN@EGCNPLHI@BOYCEHONG?3?5CPU?$CFd?5?5Idtr?3?5?$CFx?5?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DH@FDMEFLAF@BOYCEHONG?3?5The?5service?50x?$CFx?5for?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@BCGIGGHJ@BOYCEHONG?3?5Hooking?5interrupt?5?$CFx?3@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CI@FHKDENDE@BOYCEHONG?3?5OriginalFunction?$FL?$CFd?$FN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@NIHAJOH@BOYCEHONG?3?5Hook?5result?5ISR?50x?$CFp?4@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BP@JGIPOPON@BOYCEHONG?3?5Driver?5?$CFx?5Unloaded?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DC@BKJLFCJG@BOYCEHONG?3?5MyDriver_UnSupportedF@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CB@BGGHBAOC@BOYCEHONG?3?5g_MtEvent?5Signaled?5?$AN?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@LFAMJBEO@BOYCEHONG?3?5_L?$CF02x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@LDAFGMEA@BOYCEHONG?3?5_Q?$CF02x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@BKNFOJIN@ntmdrv?4cpp?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LCLMJH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5DISPATCH_L@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CG@PAANBFJP@BOYCEHONG?3?5PsTerminateSystemThre@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@PIFCANFM@BOYCEHONG?3?5DriverEntry?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CA@EMJBINJI@BOYCEHONG?3?5Driver?5run?5in?5CPU?$CFd?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1DA@HHPPAKBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CC@NADPNJBH@BOYCEHONG?3?5IoCreateDevice?5failed@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CG@DEICBDBO@BOYCEHONG?3?5GEXCEPTION?5in?5DriverE@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
EXTRN	__imp_RtlAssert:PROC
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	DbgPrint:PROC
EXTRN	__imp_KeInitializeEvent:PROC
EXTRN	__imp_KeResetEvent:PROC
EXTRN	__imp_KeSetEvent:PROC
EXTRN	__imp_KeRevertToUserAffinityThread:PROC
EXTRN	__imp_KeSetSystemAffinityThread:PROC
EXTRN	__imp_KeWaitForSingleObject:PROC
EXTRN	__imp_KeInitializeSpinLock:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_PsTerminateSystemThread:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_ZwClose:PROC
EXTRN	SaveOriginalFunctionPtr:PROC
EXTRN	SaveHookFunction:PROC
EXTRN	?QueryCommand@@YAEXZ:PROC			; QueryCommand
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_SEH:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_KeNumberProcessors:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+143
	DD	imagerel $unwind$?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HookISR@@YAXGPEA_KH@Z DD imagerel $LN9
	DD	imagerel $LN9+544
	DD	imagerel $unwind$?HookISR@@YAXGPEA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?log2@@YAEI@Z DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?log2@@YAEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$display DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$display
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverUnload DD imagerel $LN3
	DD	imagerel $LN3+138
	DD	imagerel $unwind$DriverUnload
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN15
	DD	imagerel $LN15+512
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry$filt$0 DD imagerel DriverEntry$filt$0
	DD	imagerel DriverEntry$filt$0+21
	DD	imagerel $unwind$DriverEntry$filt$0
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MyDriver_UnSupportedFunction DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$MyDriver_UnSupportedFunction
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SystemMtThread@@YAXPEAX@Z DD imagerel $LN14
	DD	imagerel $LN14+336
	DD	imagerel $unwind$?SystemMtThread@@YAXPEAX@Z
pdata	ENDS
;	COMDAT ??_C@_0CG@DEICBDBO@BOYCEHONG?3?5GEXCEPTION?5in?5DriverE@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CG@DEICBDBO@BOYCEHONG?3?5GEXCEPTION?5in?5DriverE@PBOPGDP@ DB 'BOYC'
	DB	'EHONG: GEXCEPTION in DriverEntry', 0aH, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CC@NADPNJBH@BOYCEHONG?3?5IoCreateDevice?5failed@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CC@NADPNJBH@BOYCEHONG?3?5IoCreateDevice?5failed@PBOPGDP@ DB 'BOYCE'
	DB	'HONG: IoCreateDevice failed', 0aH, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'S', 00H, 'c'
	DB	00H, 'i', 00H, 'D', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1DA@HHPPAKBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1DA@HHPPAKBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'S', 00H, 'c', 00H, 'i', 00H, 'D', 00H, 'e', 00H, 't'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'D', 00H, 'r', 00H, 'i', 00H
	DB	'v', 00H, 'e', 00H, 'r', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CA@EMJBINJI@BOYCEHONG?3?5Driver?5run?5in?5CPU?$CFd?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CA@EMJBINJI@BOYCEHONG?3?5Driver?5run?5in?5CPU?$CFd?6?$AA@PBOPGDP@ DB 'B'
	DB	'OYCEHONG: Driver run in CPU%d', 0aH, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0BI@PIFCANFM@BOYCEHONG?3?5DriverEntry?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0BI@PIFCANFM@BOYCEHONG?3?5DriverEntry?6?$AA@PBOPGDP@ DB 'BOYCEHONG:'
	DB	' DriverEntry', 0aH, 00H			;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CG@PAANBFJP@BOYCEHONG?3?5PsTerminateSystemThre@FNODOBFM@
text$s	SEGMENT
??_C@_0CG@PAANBFJP@BOYCEHONG?3?5PsTerminateSystemThre@FNODOBFM@ DB 'BOYCE'
	DB	'HONG: PsTerminateSystemThread ', 0dH, 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LCLMJH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5DISPATCH_L@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LCLMJH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5DISPATCH_L@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() <= DISPATCH_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@BKNFOJIN@ntmdrv?4cpp?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@BKNFOJIN@ntmdrv?4cpp?$AA@FNODOBFM@ DB 'ntmdrv.cpp', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@LDAFGMEA@BOYCEHONG?3?5_Q?$CF02x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@LDAFGMEA@BOYCEHONG?3?5_Q?$CF02x?6?$AA@FNODOBFM@ DB 'BOYCEHONG: '
	DB	'_Q%02x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@LFAMJBEO@BOYCEHONG?3?5_L?$CF02x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@LFAMJBEO@BOYCEHONG?3?5_L?$CF02x?6?$AA@FNODOBFM@ DB 'BOYCEHONG: '
	DB	'_L%02x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@BGGHBAOC@BOYCEHONG?3?5g_MtEvent?5Signaled?5?$AN?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@BGGHBAOC@BOYCEHONG?3?5g_MtEvent?5Signaled?5?$AN?6@FNODOBFM@ DB 'B'
	DB	'OYCEHONG: g_MtEvent Signaled ', 0dH, 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DC@BKJLFCJG@BOYCEHONG?3?5MyDriver_UnSupportedF@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DC@BKJLFCJG@BOYCEHONG?3?5MyDriver_UnSupportedF@NNGAKEGL@ DB 'BOYCE'
	DB	'HONG: MyDriver_UnSupportedFunction Called ', 0dH, 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BP@JGIPOPON@BOYCEHONG?3?5Driver?5?$CFx?5Unloaded?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BP@JGIPOPON@BOYCEHONG?3?5Driver?5?$CFx?5Unloaded?6?$AA@NNGAKEGL@ DB 'B'
	DB	'OYCEHONG: Driver %x Unloaded', 0aH, 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@NNGAKEGL@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'S', 00H, 'c'
	DB	00H, 'i', 00H, 'D', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CD@NIHAJOH@BOYCEHONG?3?5Hook?5result?5ISR?50x?$CFp?4@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@NIHAJOH@BOYCEHONG?3?5Hook?5result?5ISR?50x?$CFp?4@FNODOBFM@ DB 'B'
	DB	'OYCEHONG: Hook result ISR 0x%p.', 0dH, 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CI@FHKDENDE@BOYCEHONG?3?5OriginalFunction?$FL?$CFd?$FN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@FHKDENDE@BOYCEHONG?3?5OriginalFunction?$FL?$CFd?$FN?5@FNODOBFM@ DB 'B'
	DB	'OYCEHONG: OriginalFunction[%d] 0x%p.', 0dH, 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@BCGIGGHJ@BOYCEHONG?3?5Hooking?5interrupt?5?$CFx?3@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@BCGIGGHJ@BOYCEHONG?3?5Hooking?5interrupt?5?$CFx?3@FNODOBFM@ DB 'B'
	DB	'OYCEHONG: Hooking interrupt %x: ISR 0x%p --> 0x%p.', 0dH, 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DH@FDMEFLAF@BOYCEHONG?3?5The?5service?50x?$CFx?5for?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DH@FDMEFLAF@BOYCEHONG?3?5The?5service?50x?$CFx?5for?5@FNODOBFM@ DB 'B'
	DB	'OYCEHONG: The service 0x%x for CPU%d already hooked.', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@EGCNPLHI@BOYCEHONG?3?5CPU?$CFd?5?5Idtr?3?5?$CFx?5?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@EGCNPLHI@BOYCEHONG?3?5CPU?$CFd?5?5Idtr?3?5?$CFx?5?6?$AA@FNODOBFM@ DB 'B'
	DB	'OYCEHONG: CPU%d  Idtr: %x ', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SystemMtThread@@YAXPEAX@Z DD 030902H
	DD	06001601H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MyDriver_UnSupportedFunction DD 030e02H
	DD	06001601H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry$filt$0 DD 040602H
	DD	06030602H
	DD	050027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 05241aH
	DD	06001602H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_SEH
	DD	01H
	DD	imagerel $LN15+274
	DD	imagerel $LN15+470
	DD	imagerel DriverEntry$filt$0
	DD	imagerel $LN15+470
	DD	0c1H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverUnload DD 030902H
	DD	06001601H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$display DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?log2@@YAEI@Z DD 030802H
	DD	06001601H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HookISR@@YAXGPEA_KH@Z DD 031302H
	DD	06001601H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z DD 051e1aH
	DD	06001603H
	DD	0700bc20fH
	DD	0600aH
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z DD 051e1aH
	DD	06001603H
	DD	0700b820fH
	DD	0600aH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT ?SystemMtThread@@YAXPEAX@Z
_TEXT	SEGMENT
i$ = 32
eventNumber$ = 33
GPE_Status$ = 36
tv73 = 40
tv136 = 44
pvContext$ = 64
?SystemMtThread@@YAXPEAX@Z PROC				; SystemMtThread, COMDAT

; 363  : {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 364  : 	unsigned long GPE_Status = 0;

	mov	DWORD PTR GPE_Status$[rsp], 0

; 365  : 	UINT8 i, eventNumber = 0;

	mov	BYTE PTR eventNumber$[rsp], 0
$LN2@SystemMtTh:

; 366  : 	KIRQL irql;
; 367  : 
; 368  : 	while (!gExit)

	cmp	DWORD PTR ?gExit@@3HA, 0		; gExit
	jne	$LN3@SystemMtTh

; 369  : 	{
; 370  : 		//KeWaitForSingleObject(&g_MtEvent, Executive, KernelMode, 0, 0);
; 371  : 		//KeResetEvent(&g_MtEvent);
; 372  : 		DebugPrint(("BOYCEHONG: g_MtEvent Signaled \r\n"));

	lea	rcx, OFFSET FLAT:??_C@_0CB@BGGHBAOC@BOYCEHONG?3?5g_MtEvent?5Signaled?5?$AN?6@FNODOBFM@
	call	DbgPrint

; 373  : 		if (gExit)

	cmp	DWORD PTR ?gExit@@3HA, 0		; gExit
	je	SHORT $LN6@SystemMtTh

; 374  : 			break;

	jmp	$LN3@SystemMtTh
$LN6@SystemMtTh:

; 375  : 
; 376  : 		i = 0;

	mov	BYTE PTR i$[rsp], 0
$LN4@SystemMtTh:

; 377  : 		
; 378  : 		while (!(GPE_Status = _inpd(GPE0_STATUS_BASE + 4 * i++)))

	movzx	eax, BYTE PTR i$[rsp]
	shl	eax, 2
	add	eax, 6272				; 00001880H
	mov	DWORD PTR tv73[rsp], eax
	movzx	eax, BYTE PTR i$[rsp]
	inc	al
	mov	BYTE PTR i$[rsp], al
	movzx	edx, WORD PTR tv73[rsp]
	in	eax, dx
	mov	DWORD PTR GPE_Status$[rsp], eax
	cmp	DWORD PTR GPE_Status$[rsp], 0
	jne	SHORT $LN5@SystemMtTh

; 379  : 		if (4 == i)

	movzx	eax, BYTE PTR i$[rsp]
	cmp	eax, 4
	jne	SHORT $LN7@SystemMtTh

; 380  : 		    break;

	jmp	SHORT $LN5@SystemMtTh
$LN7@SystemMtTh:

; 381  : 
; 382  : 		if (!GPE_Status) {

	jmp	SHORT $LN4@SystemMtTh
$LN5@SystemMtTh:
	cmp	DWORD PTR GPE_Status$[rsp], 0
	jne	SHORT $LN8@SystemMtTh

; 383  : 		eventNumber = log2(GPE_Status) + (i - 1) * 32;

	mov	ecx, DWORD PTR GPE_Status$[rsp]
	call	?log2@@YAEI@Z				; log2
	movzx	eax, al
	movzx	ecx, BYTE PTR i$[rsp]
	dec	ecx
	imul	ecx, ecx, 32				; 00000020H
	add	eax, ecx
	mov	BYTE PTR eventNumber$[rsp], al

; 384  : 		DebugPrint(("BOYCEHONG: _L%02x\n", eventNumber));

	movzx	eax, BYTE PTR eventNumber$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BD@LFAMJBEO@BOYCEHONG?3?5_L?$CF02x?6?$AA@FNODOBFM@
	call	DbgPrint

; 385  : 		}
; 386  : 		else {

	jmp	SHORT $LN9@SystemMtTh
$LN8@SystemMtTh:

; 387  : 			//KeAcquireSpinLock(&NotifyLock, &irql);
; 388  : 			eventNumber = QueryCommand();

	call	?QueryCommand@@YAEXZ			; QueryCommand
	mov	BYTE PTR eventNumber$[rsp], al

; 389  : 			//KeReleaseSpinLock(&NotifyLock, irql);
; 390  : 			if(eventNumber)

	movzx	eax, BYTE PTR eventNumber$[rsp]
	test	eax, eax
	je	SHORT $LN10@SystemMtTh

; 391  : 				DebugPrint(("BOYCEHONG: _Q%02x\n", eventNumber));

	movzx	eax, BYTE PTR eventNumber$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BD@LDAFGMEA@BOYCEHONG?3?5_Q?$CF02x?6?$AA@FNODOBFM@
	call	DbgPrint
$LN10@SystemMtTh:
$LN9@SystemMtTh:

; 392  : 		}
; 393  : 		
; 394  : 	}

	jmp	$LN2@SystemMtTh
$LN3@SystemMtTh:

; 395  : 
; 396  : 	gExit = FALSE;

	mov	DWORD PTR ?gExit@@3HA, 0		; gExit

; 397  : 	ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	call	KeGetCurrentIrql
	movzx	eax, al
	cmp	eax, 2
	jle	SHORT $LN12@SystemMtTh
	xor	r9d, r9d
	mov	r8d, 397				; 0000018dH
	lea	rdx, OFFSET FLAT:??_C@_0L@BKNFOJIN@ntmdrv?4cpp?$AA@FNODOBFM@
	lea	rcx, OFFSET FLAT:??_C@_0CF@LCLMJH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5DISPATCH_L@FNODOBFM@
	call	QWORD PTR __imp_RtlAssert
	mov	DWORD PTR tv136[rsp], 0
	jmp	SHORT $LN13@SystemMtTh
$LN12@SystemMtTh:
	mov	DWORD PTR tv136[rsp], 1
$LN13@SystemMtTh:

; 398  : 	KeSetEvent(&g_ExitEvent, 0, FALSE);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?g_ExitEvent@@3U_KEVENT@@A ; g_ExitEvent
	call	QWORD PTR __imp_KeSetEvent

; 399  : 	DebugPrint(("BOYCEHONG: PsTerminateSystemThread \r\n"));

	lea	rcx, OFFSET FLAT:??_C@_0CG@PAANBFJP@BOYCEHONG?3?5PsTerminateSystemThre@FNODOBFM@
	call	DbgPrint

; 400  : 	PsTerminateSystemThread(STATUS_SUCCESS);

	xor	ecx, ecx
	call	QWORD PTR __imp_PsTerminateSystemThread

; 401  : }

	add	rsp, 56					; 00000038H
	ret	0
?SystemMtThread@@YAXPEAX@Z ENDP				; SystemMtThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT MyDriver_UnSupportedFunction
PAGE	SEGMENT
NtStatus$ = 32
DeviceObject$ = 64
Irp$ = 72
MyDriver_UnSupportedFunction PROC			; COMDAT

; 354  : NTSTATUS MyDriver_UnSupportedFunction(PDEVICE_OBJECT DeviceObject, PIRP Irp) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 355  : 	NTSTATUS NtStatus = STATUS_NOT_SUPPORTED;

	mov	DWORD PTR NtStatus$[rsp], -1073741637	; ffffffffc00000bbH

; 356  : 	
; 357  : 	DebugPrint(("BOYCEHONG: MyDriver_UnSupportedFunction Called \r\n"));

	lea	rcx, OFFSET FLAT:??_C@_0DC@BKJLFCJG@BOYCEHONG?3?5MyDriver_UnSupportedF@NNGAKEGL@
	call	DbgPrint

; 358  : 
; 359  : 	return NtStatus;

	mov	eax, DWORD PTR NtStatus$[rsp]

; 360  : }

	add	rsp, 56					; 00000038H
	ret	0
MyDriver_UnSupportedFunction ENDP
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT DriverEntry
INIT	SEGMENT
index$ = 64
NtStatus$ = 68
pDeviceObject$ = 72
hThread$ = 80
driverName$ = 88
dosDeviceName$ = 104
hookFunction$ = 128
__$ArrayPad$ = 192
pDriverObject$ = 224
pRegistryPath$ = 232
DriverEntry PROC					; COMDAT

; 407  : {

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 208				; 000000d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 408  : 	NTSTATUS NtStatus = STATUS_SUCCESS;

	mov	DWORD PTR NtStatus$[rsp], 0

; 409  : 	UINT32 index = 0;

	mov	DWORD PTR index$[rsp], 0

; 410  : 	PDEVICE_OBJECT pDeviceObject = NULL;

	mov	QWORD PTR pDeviceObject$[rsp], 0

; 411  : 	UNICODE_STRING driverName, dosDeviceName;
; 412  : 	ULONG64 hookFunction[MAX_PROCESSOR_NUMBER] = { 0 };

	mov	QWORD PTR hookFunction$[rsp], 0
	lea	rax, QWORD PTR hookFunction$[rsp+8]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 56					; 00000038H
	rep stosb

; 413  : 	HANDLE hThread;
; 414  : 	//KIRQL oldIrql;
; 415  : 
; 416  : 	DebugPrint(("BOYCEHONG: DriverEntry\n"));

	lea	rcx, OFFSET FLAT:??_C@_0BI@PIFCANFM@BOYCEHONG?3?5DriverEntry?6?$AA@PBOPGDP@
	call	DbgPrint

; 417  : 	
; 418  : 	KeInitializeEvent(&g_MtEvent, NotificationEvent, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?g_MtEvent@@3U_KEVENT@@A ; g_MtEvent
	call	QWORD PTR __imp_KeInitializeEvent

; 419  : 	KeInitializeEvent(&g_ExitEvent, NotificationEvent, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?g_ExitEvent@@3U_KEVENT@@A ; g_ExitEvent
	call	QWORD PTR __imp_KeInitializeEvent

; 420  : 	KeInitializeSpinLock(&NotifyLock);

	lea	rcx, OFFSET FLAT:?NotifyLock@@3_KA	; NotifyLock
	call	QWORD PTR __imp_KeInitializeSpinLock

; 421  : 	if (!PsCreateSystemThread(&hThread, 0, 0, 0, 0, (PKSTART_ROUTINE)SystemMtThread, 0))

	mov	QWORD PTR [rsp+48], 0
	lea	rax, OFFSET FLAT:?SystemMtThread@@YAXPEAX@Z ; SystemMtThread
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR hThread$[rsp]
	call	QWORD PTR __imp_PsCreateSystemThread
	test	eax, eax
	jne	SHORT $LN5@DriverEntr

; 422  : 	{
; 423  : 		ZwClose(hThread);

	mov	rcx, QWORD PTR hThread$[rsp]
	call	QWORD PTR __imp_ZwClose
$LN5@DriverEntr:

; 424  : 	}
; 425  : 
; 426  : 	DebugPrint(("BOYCEHONG: Driver run in CPU%d\n", KeGetCurrentProcessorNumber()));

	call	KeGetCurrentProcessorNumber
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CA@EMJBINJI@BOYCEHONG?3?5Driver?5run?5in?5CPU?$CFd?6?$AA@PBOPGDP@
	call	DbgPrint

; 427  : 
; 428  : 	/*
; 429  : 	oldIrql = KeGetCurrentIrql();
; 430  : 	ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 431  : 	KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
; 432  : 	KeLowerIrql(oldIrql);
; 433  : 	*/
; 434  : 
; 435  : 	RtlInitUnicodeString(&driverName, L"\\Device\\SciDetectDriver");

	lea	rdx, OFFSET FLAT:??_C@_1DA@HHPPAKBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@
	lea	rcx, QWORD PTR driverName$[rsp]
	call	QWORD PTR __imp_RtlInitUnicodeString

; 436  : 	RtlInitUnicodeString(&dosDeviceName, L"\\DosDevices\\SciDetectDriver");

	lea	rdx, OFFSET FLAT:??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@PBOPGDP@
	lea	rcx, QWORD PTR dosDeviceName$[rsp]
	call	QWORD PTR __imp_RtlInitUnicodeString
	npad	1

; 437  : 
; 438  : 	__try {
; 439  : 
; 440  : 		NtStatus = IoCreateDevice(pDriverObject, 0, &driverName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);

	lea	rax, QWORD PTR pDeviceObject$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	BYTE PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 256			; 00000100H
	mov	r9d, 34					; 00000022H
	lea	r8, QWORD PTR driverName$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	call	QWORD PTR __imp_IoCreateDevice
	mov	DWORD PTR NtStatus$[rsp], eax

; 441  : 
; 442  : 		if (NtStatus == STATUS_SUCCESS) {

	cmp	DWORD PTR NtStatus$[rsp], 0
	jne	SHORT $LN7@DriverEntr

; 443  : 			/* MajorFunction: is a list of function pointers for entry points into the driver. */
; 444  : 			for (index = 0; index < IRP_MJ_MAXIMUM_FUNCTION; index++)

	mov	DWORD PTR index$[rsp], 0
	jmp	SHORT $LN4@DriverEntr
$LN2@DriverEntr:
	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN4@DriverEntr:
	cmp	DWORD PTR index$[rsp], 27
	jae	SHORT $LN3@DriverEntr

; 445  : 				pDriverObject->MajorFunction[index] = MyDriver_UnSupportedFunction;

	mov	eax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	lea	rdx, OFFSET FLAT:MyDriver_UnSupportedFunction
	mov	QWORD PTR [rcx+rax*8+112], rdx
	jmp	SHORT $LN2@DriverEntr
$LN3@DriverEntr:

; 446  : 
; 447  : 			/* DriverUnload is required to be able to dynamically unload the driver. */
; 448  : 			pDriverObject->DriverUnload = DriverUnload;

	mov	rax, QWORD PTR pDriverObject$[rsp]
	lea	rcx, OFFSET FLAT:DriverUnload
	mov	QWORD PTR [rax+104], rcx

; 449  : 			pDeviceObject->Flags |= 0;

	mov	rax, QWORD PTR pDeviceObject$[rsp]
	mov	ecx, DWORD PTR [rax+48]
	mov	DWORD PTR [rax+48], ecx

; 450  : 			pDeviceObject->Flags &= (~DO_DEVICE_INITIALIZING);

	mov	rax, QWORD PTR pDeviceObject$[rsp]
	mov	eax, DWORD PTR [rax+48]
	btr	eax, 7
	mov	rcx, QWORD PTR pDeviceObject$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 451  : 
; 452  : 			/* Create a Symbolic Link to the device. MyDriver -> \Device\MyDriver */
; 453  : 			IoCreateSymbolicLink(&dosDeviceName, &driverName);

	lea	rdx, QWORD PTR driverName$[rsp]
	lea	rcx, QWORD PTR dosDeviceName$[rsp]
	call	QWORD PTR __imp_IoCreateSymbolicLink

; 454  : 
; 455  : 			/* hook IDT */
; 456  : /*			for (index = 0; index < MAX_PROCESSOR_NUMBER; index++) {
; 457  : 				hookFunction[index] = (ULONG64)HookRoutine;
; 458  : 			}
; 459  : 			HookISR(0xb0, (ULONG64 *)hookFunction, FALSE);
; 460  : */	
; 461  : 		}
; 462  : 		else {

	jmp	SHORT $LN8@DriverEntr
$LN7@DriverEntr:

; 463  : 			DebugPrint(("BOYCEHONG: IoCreateDevice failed\n"));

	lea	rcx, OFFSET FLAT:??_C@_0CC@NADPNJBH@BOYCEHONG?3?5IoCreateDevice?5failed@PBOPGDP@
	call	DbgPrint
$LN8@DriverEntr:

; 464  : 		}
; 465  : 	}

	jmp	SHORT $LN14@DriverEntr
$LN12@DriverEntr:

; 466  : 	__except (EXCEPTION_EXECUTE_HANDLER)
; 467  : 	{
; 468  : 		DebugPrint(("BOYCEHONG: GEXCEPTION in DriverEntry\n"));

	lea	rcx, OFFSET FLAT:??_C@_0CG@DEICBDBO@BOYCEHONG?3?5GEXCEPTION?5in?5DriverE@PBOPGDP@
	call	DbgPrint
	npad	1
$LN14@DriverEntr:

; 469  : 		//KdPrint(("BOYCEHON: GEXCEPTION in DriverEntry\n"));
; 470  : 	}
; 471  : 	
; 472  : 	return NtStatus;

	mov	eax, DWORD PTR NtStatus$[rsp]
$LN10@DriverEntr:

; 473  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	rdi
	ret	0
DriverEntry ENDP
INIT	ENDS
;	COMDAT INIT$x
INIT$x	SEGMENT
index$ = 64
NtStatus$ = 68
pDeviceObject$ = 72
hThread$ = 80
driverName$ = 88
dosDeviceName$ = 104
hookFunction$ = 128
__$ArrayPad$ = 192
pDriverObject$ = 224
pRegistryPath$ = 232
DriverEntry$filt$0 PROC
	push	rbp
	sub	rsp, 64					; 00000040H
	mov	rbp, rdx
$LN11@DriverEntr:

; 466  : 	__except (EXCEPTION_EXECUTE_HANDLER)

	mov	eax, 1
$LN13@DriverEntr:
	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
	int	3
DriverEntry$filt$0 ENDP
INIT$x	ENDS
; Function compile flags: /Odtp
;	COMDAT INIT$x
INIT$x	SEGMENT
index$ = 64
NtStatus$ = 68
pDeviceObject$ = 72
hThread$ = 80
driverName$ = 88
dosDeviceName$ = 104
hookFunction$ = 128
__$ArrayPad$ = 192
pDriverObject$ = 224
pRegistryPath$ = 232
DriverEntry$filt$0 PROC
	push	rbp
	sub	rsp, 64					; 00000040H
	mov	rbp, rdx
$LN11@DriverEntr:

; 466  : 	__except (EXCEPTION_EXECUTE_HANDLER)

	mov	eax, 1
$LN13@DriverEntr:
	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
	int	3
DriverEntry$filt$0 ENDP
INIT$x	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT DriverUnload
PAGE	SEGMENT
pDev$ = 48
dosDeviceName$ = 56
DriverObject$ = 96
DriverUnload PROC					; COMDAT

; 331  : extern "C" VOID DriverUnload(__in PDRIVER_OBJECT  DriverObject) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 332  : 	/* local variables */
; 333  : 	PDEVICE_OBJECT pDev;
; 334  : 	UNICODE_STRING dosDeviceName;
; 335  : 
; 336  : 	gExit = TRUE;

	mov	DWORD PTR ?gExit@@3HA, 1		; gExit

; 337  : 	//KeSetEvent(&g_MtEvent, 0, FALSE);
; 338  : 	KeWaitForSingleObject(&g_ExitEvent, Executive, KernelMode, 0, 0);

	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?g_ExitEvent@@3U_KEVENT@@A ; g_ExitEvent
	call	QWORD PTR __imp_KeWaitForSingleObject

; 339  : 	KeResetEvent(&g_ExitEvent);

	lea	rcx, OFFSET FLAT:?g_ExitEvent@@3U_KEVENT@@A ; g_ExitEvent
	call	QWORD PTR __imp_KeResetEvent

; 340  : 	/* restore the hook */
; 341  : //	HookISR(0xb0, (ULONG64 *)OriginalFunction, TRUE);
; 342  : 
; 343  : 	/* delete the driver */
; 344  : 	pDev = DriverObject->DeviceObject;

	mov	rax, QWORD PTR DriverObject$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pDev$[rsp], rax

; 345  : 	RtlInitUnicodeString(&dosDeviceName, L"\\DosDevices\\SciDetectDriver");

	lea	rdx, OFFSET FLAT:??_C@_1DI@BMCGHMCK@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAS?$AAc?$AAi?$AAD?$AAe?$AAt?$AAe?$AAc?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@NNGAKEGL@
	lea	rcx, QWORD PTR dosDeviceName$[rsp]
	call	QWORD PTR __imp_RtlInitUnicodeString

; 346  : 	IoDeleteSymbolicLink(&dosDeviceName);

	lea	rcx, QWORD PTR dosDeviceName$[rsp]
	call	QWORD PTR __imp_IoDeleteSymbolicLink

; 347  : 	IoDeleteDevice(pDev);

	mov	rcx, QWORD PTR pDev$[rsp]
	call	QWORD PTR __imp_IoDeleteDevice

; 348  : 	DebugPrint(("BOYCEHONG: Driver %x Unloaded\n", pDev));

	mov	rdx, QWORD PTR pDev$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BP@JGIPOPON@BOYCEHONG?3?5Driver?5?$CFx?5Unloaded?6?$AA@NNGAKEGL@
	call	DbgPrint

; 349  : }

	add	rsp, 88					; 00000058H
	ret	0
DriverUnload ENDP
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT display
_TEXT	SEGMENT
display	PROC						; COMDAT

; 194  : void display(void) {

$LN3:
	sub	rsp, 40					; 00000028H

; 195  : 	KeSetEvent(&g_MtEvent, 0, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?g_MtEvent@@3U_KEVENT@@A ; g_MtEvent
	call	QWORD PTR __imp_KeSetEvent

; 196  : }

	add	rsp, 40					; 00000028H
	ret	0
display	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT ?log2@@YAEI@Z
_TEXT	SEGMENT
value$ = 48
?log2@@YAEI@Z PROC					; log2, COMDAT

; 183  : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 184  : 	if (1 == value)

	cmp	DWORD PTR value$[rsp], 1
	jne	SHORT $LN2@log2

; 185  : 		return 0;

	xor	al, al
	jmp	SHORT $LN1@log2

; 186  : 	else

	jmp	SHORT $LN3@log2
$LN2@log2:

; 187  : 		return (1 + log2(value >> 1));

	mov	eax, DWORD PTR value$[rsp]
	shr	eax, 1
	mov	ecx, eax
	call	?log2@@YAEI@Z				; log2
	movzx	eax, al
	inc	eax
$LN3@log2:
$LN1@log2:

; 188  : }

	add	rsp, 40					; 00000028H
	ret	0
?log2@@YAEI@Z ENDP					; log2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT ?HookISR@@YAXGPEA_KH@Z
_TEXT	SEGMENT
i$ = 32
isr$ = 40
pTargetEntry$ = 48
CR0_Context$ = 56
index$ = 80
hookFunction$ = 88
IsRestore$ = 96
?HookISR@@YAXGPEA_KH@Z PROC				; HookISR, COMDAT

; 201  : VOID HookISR(UINT16 index, ULONG64 * hookFunction, BOOL IsRestore) {

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 202  : 	ULONG64 isr = 0;

	mov	QWORD PTR isr$[rsp], 0

; 203  : 	PKIDTENTRY64 pTargetEntry;
; 204  : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 205  : 	unsigned __int64 CR0_Context = 0;

	mov	QWORD PTR CR0_Context$[rsp], 0

; 206  : 
; 207  : 	for (; i < KeNumberProcessors; i++)

	jmp	SHORT $LN4@HookISR
$LN2@HookISR:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@HookISR:
	mov	rax, QWORD PTR __imp_KeNumberProcessors
	movzx	eax, BYTE PTR [rax]
	movsx	eax, al
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@HookISR

; 208  : 	{
; 209  : 		pTargetEntry = GetTargetEntry(i, index);

	movzx	edx, WORD PTR index$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z ; GetTargetEntry
	mov	QWORD PTR pTargetEntry$[rsp], rax

; 210  : 		isr = pTargetEntry->IDT_ENTRY.OffsetHigh;

	mov	rax, QWORD PTR pTargetEntry$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	QWORD PTR isr$[rsp], rax

; 211  : 		isr <<= 32;

	mov	rax, QWORD PTR isr$[rsp]
	shl	rax, 32					; 00000020H
	mov	QWORD PTR isr$[rsp], rax

; 212  : 		isr += (pTargetEntry->IDT_ENTRY.OffsetLow + (pTargetEntry->IDT_ENTRY.OffsetMiddle << 16));

	mov	rax, QWORD PTR pTargetEntry$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR pTargetEntry$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	shl	ecx, 16
	add	eax, ecx
	cdqe
	mov	rcx, QWORD PTR isr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR isr$[rsp], rax

; 213  : 		if (isr == hookFunction[i]) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hookFunction$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR isr$[rsp], rax
	jne	SHORT $LN5@HookISR

; 214  : 			DebugPrint(("BOYCEHONG: The service 0x%x for CPU%d already hooked.\n", index, i));

	movzx	eax, WORD PTR index$[rsp]
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0DH@FDMEFLAF@BOYCEHONG?3?5The?5service?50x?$CFx?5for?5@FNODOBFM@
	call	DbgPrint

; 215  : 		}
; 216  : 		else {

	jmp	$LN6@HookISR
$LN5@HookISR:

; 217  : 			DebugPrint(("BOYCEHONG: Hooking interrupt %x: ISR 0x%p --> 0x%p.\r\n", index, isr, hookFunction[i]));

	movsxd	rax, DWORD PTR i$[rsp]
	movzx	ecx, WORD PTR index$[rsp]
	mov	rdx, QWORD PTR hookFunction$[rsp]
	mov	r9, QWORD PTR [rdx+rax*8]
	mov	r8, QWORD PTR isr$[rsp]
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0DG@BCGIGGHJ@BOYCEHONG?3?5Hooking?5interrupt?5?$CFx?3@FNODOBFM@
	call	DbgPrint

; 218  : 			if (!IsRestore) {

	cmp	DWORD PTR IsRestore$[rsp], 0
	jne	SHORT $LN7@HookISR

; 219  : 				OriginalFunction[i] = isr;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?OriginalFunction@@3PA_KA ; OriginalFunction
	mov	rdx, QWORD PTR isr$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 220  : 				DebugPrint(("BOYCEHONG: OriginalFunction[%d] 0x%p.\r\n", i, isr));

	mov	r8, QWORD PTR isr$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0CI@FHKDENDE@BOYCEHONG?3?5OriginalFunction?$FL?$CFd?$FN?5@FNODOBFM@
	call	DbgPrint
$LN7@HookISR:

; 221  : 			}
; 222  : 			
; 223  : 			/* Set address of the IDT table */
; 224  : 			_disable();

	cli

; 225  : 			//DisableWriteProtect(&CR0_Context);
; 226  : 			pTargetEntry->IDT_ENTRY.OffsetHigh = (UINT32)(hookFunction[i] >> 32);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hookFunction$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR pTargetEntry$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 227  : 			pTargetEntry->IDT_ENTRY.OffsetMiddle = (UINT16)(hookFunction[i] >> 16);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR hookFunction$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	shr	rax, 16
	mov	rcx, QWORD PTR pTargetEntry$[rsp]
	mov	WORD PTR [rcx+6], ax

; 228  : 			pTargetEntry->IDT_ENTRY.OffsetLow = (UINT16)hookFunction[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR pTargetEntry$[rsp]
	mov	rdx, QWORD PTR hookFunction$[rsp]
	movzx	eax, WORD PTR [rdx+rax*8]
	mov	WORD PTR [rcx], ax

; 229  : 			//EnableWriteProtect(CR0_Context);
; 230  : 			_enable();

	sti
$LN6@HookISR:

; 231  : 		}
; 232  : 		pTargetEntry = GetTargetEntry(i, index);

	movzx	edx, WORD PTR index$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	call	?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z ; GetTargetEntry
	mov	QWORD PTR pTargetEntry$[rsp], rax

; 233  : 		isr = pTargetEntry->IDT_ENTRY.OffsetHigh;

	mov	rax, QWORD PTR pTargetEntry$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	QWORD PTR isr$[rsp], rax

; 234  : 		isr <<= 32;

	mov	rax, QWORD PTR isr$[rsp]
	shl	rax, 32					; 00000020H
	mov	QWORD PTR isr$[rsp], rax

; 235  : 		isr += (pTargetEntry->IDT_ENTRY.OffsetLow + (pTargetEntry->IDT_ENTRY.OffsetMiddle << 16));

	mov	rax, QWORD PTR pTargetEntry$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR pTargetEntry$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	shl	ecx, 16
	add	eax, ecx
	cdqe
	mov	rcx, QWORD PTR isr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR isr$[rsp], rax

; 236  : 		DebugPrint(("BOYCEHONG: Hook result ISR 0x%p.\r\n", isr));

	mov	rdx, QWORD PTR isr$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0CD@NIHAJOH@BOYCEHONG?3?5Hook?5result?5ISR?50x?$CFp?4@FNODOBFM@
	call	DbgPrint

; 237  : 	}

	jmp	$LN2@HookISR
$LN3@HookISR:

; 238  : 	oldFunction = OriginalFunction[0];

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?OriginalFunction@@3PA_KA ; OriginalFunction
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR ?oldFunction@@3_KA, rax	; oldFunction

; 239  : 	SaveOriginalFunctionPtr((unsigned __int64)OriginalFunction);

	lea	rcx, OFFSET FLAT:?OriginalFunction@@3PA_KA ; OriginalFunction
	call	SaveOriginalFunctionPtr

; 240  : 	SaveHookFunction((unsigned __int64)display);

	lea	rcx, OFFSET FLAT:display
	call	SaveHookFunction

; 241  : }

	add	rsp, 72					; 00000048H
	ret	0
?HookISR@@YAXGPEA_KH@Z ENDP				; HookISR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT ?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z
_TEXT	SEGMENT
pTargetEntry$ = 32
$T1 = 40
idtr$ = 56
$T2 = 72
__$ArrayPad$ = 88
i$ = 128
index$ = 136
?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z PROC		; GetTargetEntry, COMDAT

; 168  : PKIDTENTRY64 GetTargetEntry(int i, UINT16 index) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 169  : 	/* allocate local variables */
; 170  : 	AMD64_DESCRIPTOR idtr;
; 171  : 	PKIDTENTRY64 pTargetEntry;
; 172  : 
; 173  : 	idtr = GetIdtrAddress(i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z ; GetIdtrAddress
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 10
	rep movsb
	lea	rax, QWORD PTR idtr$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 10
	rep movsb

; 174  : 
; 175  : 	/* get address of the interrupt entry we would like to hook */
; 176  : 	pTargetEntry = (KIDTENTRY64*)idtr.Base;

	mov	rax, QWORD PTR idtr$[rsp+2]
	mov	QWORD PTR pTargetEntry$[rsp], rax

; 177  : 	pTargetEntry = &pTargetEntry[index];

	movzx	eax, WORD PTR index$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR pTargetEntry$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pTargetEntry$[rsp], rax

; 178  : 
; 179  : 	return pTargetEntry;

	mov	rax, QWORD PTR pTargetEntry$[rsp]

; 180  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?GetTargetEntry@@YAPEAT_KIDTENTRY64@@HG@Z ENDP		; GetTargetEntry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\boyce_hong\desktop\acpitool-src-104\ntmdrv\mydriver2\ntmdrv.cpp
;	COMDAT ?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z
_TEXT	SEGMENT
tv72 = 32
idtr$ = 40
__$ArrayPad$ = 56
$T1 = 96
i$ = 104
?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z PROC	; GetIdtrAddress, COMDAT

; 149  : AMD64_DESCRIPTOR GetIdtrAddress(int i) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 150  : 	AMD64_DESCRIPTOR idtr;
; 151  : 
; 152  : 	/* get address of the IDT table */
; 153  : 	KeSetSystemAffinityThread((ULONG64)0x0001UL << i);

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv72[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv72[rsp]
	shl	rax, cl
	mov	rcx, rax
	call	QWORD PTR __imp_KeSetSystemAffinityThread

; 154  : 	_disable();

	cli

; 155  : 	__sidt(&idtr);

	sidt	QWORD PTR idtr$[rsp]

; 156  : 	_enable();

	sti

; 157  : 	KeRevertToUserAffinityThread();

	call	QWORD PTR __imp_KeRevertToUserAffinityThread

; 158  : 
; 159  : 	DebugPrint(("BOYCEHONG: CPU%d  Idtr: %x \n", i, idtr.Base));

	mov	r8, QWORD PTR idtr$[rsp+2]
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BN@EGCNPLHI@BOYCEHONG?3?5CPU?$CFd?5?5Idtr?3?5?$CFx?5?6?$AA@FNODOBFM@
	call	DbgPrint

; 160  : 
; 161  : 	return idtr;

	lea	rax, QWORD PTR idtr$[rsp]
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 10
	rep movsb
	mov	rax, QWORD PTR $T1[rsp]

; 162  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?GetIdtrAddress@@YA?AU_AMD64_DESCRIPTOR@@H@Z ENDP	; GetIdtrAddress
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\km\ntddk.h
;	COMDAT KeGetCurrentProcessorNumber
_TEXT	SEGMENT
KeGetCurrentProcessorNumber PROC			; COMDAT

; 5826 : 
; 5827 :     return (ULONG)__readgsbyte(0x184);

	mov	al, BYTE PTR gs:388
	movzx	eax, al

; 5828 : }

	ret	0
KeGetCurrentProcessorNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\km\wdm.h
;	COMDAT KeGetCurrentIrql
_TEXT	SEGMENT
KeGetCurrentIrql PROC					; COMDAT

; 17423: 
; 17424:     return (KIRQL)ReadCR8();

	mov	rax, cr8

; 17425: }

	ret	0
KeGetCurrentIrql ENDP
_TEXT	ENDS
END
